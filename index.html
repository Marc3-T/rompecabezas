<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rompecabezas de Amor</title>
    <link href="https://fonts.googleapis.com/css2?family=Patrick+Hand&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Patrick Hand', cursive;
            margin: 0;
            padding: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: linear-gradient(120deg, #ff758c, #ff7eb3, #fad0c4);
            touch-action: none;
        }

        #puzzle-container {
            position: relative;
            width: 300px; /* Tamaño reducido para móviles */
            height: 450px; /* Mantiene la proporción 1,333 x 2,000 */
            border: 2px solid #ff6f61; /* Borde rosado */
            background-color: #fff0f6; /* Fondo pastel rosado */
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }

        #template {
            position: absolute;
            width: 100%;
            height: 100%;
            background-image: url('t.jpg'); /* Imagen del rompecabezas */
            background-size: 300px 450px; /* Mantiene la proporción de la imagen */
            opacity: 0.3; /* Hace la plantilla semi-transparente */
            pointer-events: none;
        }

        /* Líneas de división en la plantilla */
        #template::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to right, transparent 99%, rgba(255, 111, 97, 0.5) 1%),
                        linear-gradient(to bottom, transparent 99%, rgba(255, 111, 97, 0.5) 1%);
            background-size: 100px 150px; /* Tamaño de cada pieza */
        }

        .puzzle-piece {
            position: absolute;
            cursor: grab;
            user-select: none;
            border: 2px solid #ff6f61; /* Borde rosado */
            box-sizing: border-box;
            transition: transform 0.2s ease;
            background-color: #ffe5e0; /* Fondo pastel rosado */
        }

        .puzzle-piece.correct {
            cursor: default;
            border-color: #ff477e; /* Borde rosado más oscuro */
            pointer-events: none;
        }

        #congrats-message {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #fff0f6; /* Fondo pastel rosado */
            color: #ff6f61; /* Texto rosado */
            padding: 20px;
            border-radius: 15px;
            font-size: 24px;
            text-align: center;
            z-index: 1000;
            border: 2px solid #ff6f61; /* Borde rosado */
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }

        #congrats-message img {
            width: 100%;
            max-width: 300px; /* Tamaño de la imagen */
            margin-top: 10px;
            border-radius: 10px;
            border: 2px solid #ff6f61; /* Borde rosado */
        }
    </style>
</head>
<body>
    <div id="puzzle-container">
        <div id="template"></div> <!-- Plantilla de fondo -->
    </div>
    <div id="congrats-message">
        <div>Te amo ❤️</div>
        <img src="t.jpg" alt="Imagen completada"> <!-- Imagen completa -->
    </div>

    <script>
        // Configuración del rompecabezas
        const rows = 3; // Número de filas
        const cols = 3; // Número de columnas
        const pieceWidth = 100; // Ancho de cada pieza (300 / 3)
        const pieceHeight = 150; // Alto de cada pieza (450 / 3)
        const puzzleWidth = cols * pieceWidth; // Ancho total del rompecabezas
        const puzzleHeight = rows * pieceHeight; // Alto total del rompecabezas

        // Contenedor del rompecabezas
        const puzzleContainer = document.getElementById('puzzle-container');
        puzzleContainer.style.width = `${puzzleWidth}px`;
        puzzleContainer.style.height = `${puzzleHeight}px`;

        // Mensaje de felicitación
        const congratsMessage = document.getElementById('congrats-message');

        // Crear las piezas del rompecabezas
        function createPuzzle() {
            const pieces = [];
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const piece = document.createElement('div');
                    piece.classList.add('puzzle-piece');
                    piece.style.width = `${pieceWidth}px`;
                    piece.style.height = `${pieceHeight}px`;
                    piece.style.backgroundImage = `url('t.jpg')`; /* Imagen del rompecabezas */
                    piece.style.backgroundSize = `${puzzleWidth}px ${puzzleHeight}px`;
                    piece.style.backgroundPosition = `-${j * pieceWidth}px -${i * pieceHeight}px`;

                    // Posición correcta de la pieza (relativa al contenedor del rompecabezas)
                    piece.correctX = j * pieceWidth;
                    piece.correctY = i * pieceHeight;

                    // Hacer las piezas arrastrables
                    makeDraggable(piece);

                    pieces.push(piece);
                }
            }

            // Distribuir las piezas aleatoriamente sin superponerse
            distributePieces(pieces);
        }

        // Función para distribuir las piezas sin superponerse
        function distributePieces(pieces) {
            const positions = new Set(); // Almacena las posiciones ocupadas

            pieces.forEach(piece => {
                let x, y;
                do {
                    x = Math.random() * (window.innerWidth - pieceWidth);
                    y = Math.random() * (window.innerHeight - pieceHeight);
                } while (isOverlapping(x, y, positions));

                // Registrar la posición ocupada
                positions.add(`${Math.floor(x / 10)}-${Math.floor(y / 10)}`);

                // Asignar la posición a la pieza
                piece.style.left = `${x}px`;
                piece.style.top = `${y}px`;

                document.body.appendChild(piece);
            });
        }

        // Función para verificar si una posición está ocupada
        function isOverlapping(x, y, positions) {
            const gridX = Math.floor(x / 10);
            const gridY = Math.floor(y / 10);
            return positions.has(`${gridX}-${gridY}`);
        }

        // Función para hacer las piezas arrastrables
        function makeDraggable(element) {
            let isDragging = false;
            let offsetX, offsetY;

            element.addEventListener('mousedown', (e) => {
                if (!element.classList.contains('correct')) {
                    isDragging = true;
                    offsetX = e.clientX - element.getBoundingClientRect().left;
                    offsetY = e.clientY - element.getBoundingClientRect().top;
                    element.style.cursor = 'grabbing';
                }
            });

            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const x = e.clientX - offsetX;
                    const y = e.clientY - offsetY;
                    element.style.left = `${x}px`;
                    element.style.top = `${y}px`;
                }
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    element.style.cursor = 'grab';

                    // Verificar si la pieza está en la posición correcta
                    const rect = element.getBoundingClientRect();
                    const puzzleRect = puzzleContainer.getBoundingClientRect();
                    const pieceX = rect.left - puzzleRect.left;
                    const pieceY = rect.top - puzzleRect.top;

                    // Margen de error aumentado a 30px
                    if (
                        Math.abs(pieceX - element.correctX) < 30 &&
                        Math.abs(pieceY - element.correctY) < 30
                    ) {
                        // Colocar la pieza en la posición correcta (relativa al contenedor del rompecabezas)
                        element.style.left = `${puzzleRect.left + element.correctX}px`;
                        element.style.top = `${puzzleRect.top + element.correctY}px`;
                        element.classList.add('correct');
                        element.style.cursor = 'default';

                        // Verificar si el rompecabezas está completo
                        checkCompletion();
                    }
                }
            });

            // Soporte para pantallas táctiles
            element.addEventListener('touchstart', (e) => {
                if (!element.classList.contains('correct')) {
                    isDragging = true;
                    const touch = e.touches[0];
                    offsetX = touch.clientX - element.getBoundingClientRect().left;
                    offsetY = touch.clientY - element.getBoundingClientRect().top;
                    e.preventDefault(); /* Evita el desplazamiento táctil */
                }
            });

            document.addEventListener('touchmove', (e) => {
                if (isDragging) {
                    const touch = e.touches[0];
                    const x = touch.clientX - offsetX;
                    const y = touch.clientY - offsetY;
                    element.style.left = `${x}px`;
                    element.style.top = `${y}px`;
                    e.preventDefault(); /* Evita el desplazamiento táctil */
                }
            });

            document.addEventListener('touchend', () => {
                if (isDragging) {
                    isDragging = false;

                    // Verificar si la pieza está en la posición correcta
                    const rect = element.getBoundingClientRect();
                    const puzzleRect = puzzleContainer.getBoundingClientRect();
                    const pieceX = rect.left - puzzleRect.left;
                    const pieceY = rect.top - puzzleRect.top;

                    // Margen de error aumentado a 30px
                    if (
                        Math.abs(pieceX - element.correctX) < 50 &&
                        Math.abs(pieceY - element.correctY) < 50
                    ) {
                        // Colocar la pieza en la posición correcta (relativa al contenedor del rompecabezas)
                        element.style.left = `${puzzleRect.left + element.correctX}px`;
                        element.style.top = `${puzzleRect.top + element.correctY}px`;
                        element.classList.add('correct');
                        element.style.cursor = 'default';

                        // Verificar si el rompecabezas está completo
                        checkCompletion();
                    }
                }
            });
        }

        // Verificar si el rompecabezas está completo
        function checkCompletion() {
            const pieces = document.querySelectorAll('.puzzle-piece');
            const isComplete = Array.from(pieces).every(piece => piece.classList.contains('correct'));

            if (isComplete) {
                congratsMessage.style.display = 'block';
            }
        }

        // Iniciar el rompecabezas
        createPuzzle();

        // Prevenir el desplazamiento táctil en el cuerpo
        document.body.addEventListener('touchmove', (e) => {
            e.preventDefault();
        }, { passive: false });
    </script>
</body>
</html>
